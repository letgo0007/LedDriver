/******************************************************************************
 * @file 	[driver_iw7027.c]
 *
 * IW7027 LED Driver IC driver.
 *
 * Copyright (c) 2016 SHARP CORPORATION
 *
 * @change 	[DATE]	 [EDITOR] 		[MODEL] [TYPE] 	[COMMENT]
 * ----------------------------------------------------------------------------
 * 1		20160527 Yang Zhifang	ALL		Init	Initial Version
 *
 ******************************************************************************/

/***1 Includes ****************************************************************/

#include "drv_iw7027.h"

#include "drv_uart.h"
#include "hal.h"

/***2.1 Internal Marcos *******************************************************/

#ifndef UART_DEBUG_ON
#define UART_DEBUG_ON						(0)
#endif
//CS -> SPI delay(unit:us) , see IW7027 application note
#define IW_SPI_MASTER_TRANS_START_DELAY		(50)
//SPI -> CS delay(unit:us) , see IW7027 application note
#define IW_SPI_MASTER_TRANS_STOP_DELAY		(10)
//Current change max step .
#define	IW_CURRENT_CHANGE_STEP				(0x30)

/***2.2 Internal Struct ******************************************************/

/***2.3 Internal Variables ***************************************************/

//Default Reg map for all IW7027 devices. 0x60 bytes for each device.
const uint8 Iw7027_DefaultRegMap_70XU30A[IW_DEVICE_AMOUNT * 0x60] =
{
/*IW_0*/
/*0x0x*/0x06, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00, 0xEC, 0x01,
/*0x1x*/0x13, 0x55, 0x3B, 0x62, 0x89, 0xB1, 0x40, 0xD8, 0x00, 0x27, 0x4E, 0x0F, 0x19, 0xD5, 0x0F, 0x18,
/*0x2x*/0x1E, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_1*/
/*0x0x*/0x06, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00, 0xEC, 0x01, 0x13, 0x01, 0x3B, 0x01, 0x62, 0x01,
/*0x1x*/0x89, 0x50, 0xB1, 0xD8, 0x00, 0x27, 0x00, 0x4E, 0x76, 0x9D, 0xC4, 0x33, 0xAA, 0x1E, 0x30, 0x3C,
/*0x2x*/0x67, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_2*/
/*0x0x*/0x06, 0x00, 0xEC, 0x01, 0x13, 0x01, 0x3B, 0x01, 0x62, 0x01, 0x89, 0x01, 0xB1, 0x01, 0xD8, 0x00,
/*0x1x*/0x00, 0x00, 0x27, 0x4E, 0x76, 0x9D, 0x05, 0xC4, 0xEC, 0x13, 0x3B, 0x54, 0x3C, 0x60, 0x78, 0xCE,
/*0x2x*/0xA8, 0x0F, 0xFF, 0x3F, 0xFF, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_3*/
/*0x0x*/0x06, 0x01, 0x62, 0x01, 0x89, 0x01, 0xB1, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00,
/*0x1x*/0x76, 0x01, 0x9D, 0xC4, 0xEC, 0x13, 0x55, 0x3B, 0x62, 0x89, 0xB1, 0x78, 0xC0, 0xF1, 0x9D, 0x50,
/*0x2x*/0xF1, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_4*/
/*0x0x*/0x06, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00,
/*0x1x*/0xEC, 0x55, 0x13, 0x3B, 0x62, 0x89, 0x50, 0xb1, 0xD8, 0x00, 0x00, 0x81, 0xE3, 0x3A, 0xA1, 0xE3,
/*0x2x*/0x00, 0x0F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, };

//Default Reg map for all IW7027 devices. 0x60 bytes for each device.
const uint8 Iw7027_DefaultRegMap_65SX970A[IW_DEVICE_AMOUNT * 0x60] =
{
/*IW_0*/
/*0x0x*/0x06, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00, 0xEC, 0x01,
/*0x1x*/0x13, 0x55, 0x3B, 0x62, 0x89, 0xB1, 0x40, 0xD8, 0x00, 0x27, 0x4E, 0x0F, 0x19, 0xD5, 0x0F, 0x18,
/*0x2x*/0x1E, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_1*/
/*0x0x*/0x06, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00, 0xEC, 0x01, 0x13, 0x01, 0x3B, 0x01, 0x62, 0x01,
/*0x1x*/0x89, 0x50, 0xB1, 0xD8, 0x00, 0x27, 0x00, 0x4E, 0x76, 0x9D, 0xC4, 0x33, 0xAA, 0x1E, 0x30, 0x3C,
/*0x2x*/0x67, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_2*/
/*0x0x*/0x06, 0x00, 0xEC, 0x01, 0x13, 0x01, 0x3B, 0x01, 0x62, 0x01, 0x89, 0x01, 0xB1, 0x01, 0xD8, 0x00,
/*0x1x*/0x00, 0x00, 0x27, 0x4E, 0x76, 0x9D, 0x05, 0xC4, 0xEC, 0x13, 0x3B, 0x54, 0x3C, 0x60, 0x78, 0xCE,
/*0x2x*/0xA8, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_3*/
/*0x0x*/0x06, 0x01, 0x62, 0x01, 0x89, 0x01, 0xB1, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00,
/*0x1x*/0x76, 0x01, 0x9D, 0xC4, 0xEC, 0x13, 0x55, 0x3B, 0x62, 0x89, 0xB1, 0x78, 0xC0, 0xF1, 0x9D, 0x50,
/*0x2x*/0xF1, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_4*/
/*0x0x*/0x06, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00,
/*0x1x*/0xEC, 0x55, 0x13, 0x3B, 0x62, 0x89, 0x50, 0xb1, 0xD8, 0x00, 0x00, 0x81, 0xE3, 0x3A, 0xA1, 0xE3,
/*0x2x*/0x00, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_5*/
/*0x0x*/0x06, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00,
/*0x1x*/0xEC, 0x55, 0x13, 0x3B, 0x62, 0x89, 0x50, 0xb1, 0xD8, 0x00, 0x00, 0x81, 0xE3, 0x3A, 0xA1, 0xE3,
/*0x2x*/0x00, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_6*/
/*0x0x*/0x06, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00,
/*0x1x*/0xEC, 0x55, 0x13, 0x3B, 0x62, 0x89, 0x50, 0xb1, 0xD8, 0x00, 0x00, 0x81, 0xE3, 0x3A, 0xA1, 0xE3,
/*0x2x*/0x00, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

/*IW_7*/
/*0x0x*/0x06, 0x01, 0xD8, 0x00, 0x00, 0x00, 0x27, 0x00, 0x4E, 0x00, 0x76, 0x00, 0x9D, 0x00, 0xC4, 0x00,
/*0x1x*/0xEC, 0x55, 0x13, 0x3B, 0x62, 0x89, 0x50, 0xb1, 0xD8, 0x00, 0x00, 0x81, 0xE3, 0x3A, 0xA1, 0xE3,
/*0x2x*/0x00, 0x0F, 0xFF, 0x7F, 0xFE, 0x00, 0x00, 0x42, 0x42, 0x0F, 0x12, 0x7F, 0xFF, 0xFF, 0xE5, 0xBC,
/*0x3x*/0x7D, 0xD3, 0x01, 0x16, 0xC8, 0x80, 0x44, 0x00, 0xC0, 0xA0, 0x00, 0x78, 0x08, 0x28, 0x88, 0x88,
/*0x4x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,
/*0x5x*/0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99, 0x01, 0x99,

};

//Mapping const to convert LED channel mark form "TV Front View" to "Hardware View" .
const uint8 Iw7027_LedSortMap_70XU30A[80] =
{
/*ROW0*/0x11, 0x10, 0x0F, 0x4D, 0x4E, 0x4F,
/*ROW1*/0x0E, 0x0D, 0x0C, 0x4A, 0x4B, 0x4C,
/*ROW2*/0x0B, 0x0A, 0x09, 0x47, 0x48, 0x49,
/*ROW3*/0x08, 0x07, 0x06, 0x44, 0x45, 0x46,
/*ROW4*/0x05, 0x04, 0x03, 0x41, 0x42, 0x43,
/*ROW5*/0x02, 0x01, 0x00, 0x3E, 0x3F, 0x40,
/*ROW6*/0x26, 0x25, 0x24, 0x3B, 0x3C, 0x3D,
/*ROW7*/0x23, 0x22, 0x21, 0x38, 0x39, 0x3A,
/*ROW8*/0x20, 0x1F, 0x1E, 0x35, 0x36, 0x37,
/*ROW9*/0x1D, 0x1C, 0x1B, 0x32, 0x33, 0x34,
/*ROWA*/0x1A, 0x19, 0x18, 0x2D, 0x30, 0x31,
/*ROWB*/0x17, 0x16, 0x15, 0x2A, 0x2B, 0x2C,
/*ROWC*/0x14, 0x13, 0x12, 0x27, 0x28, 0x29,
/*NC  */0x2E, 0x2F, };

const uint8 Iw7027_LedSortMap_65SX970A[IW_DEVICE_AMOUNT * 16] =
{
/*ROW0*/0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
/*ROW1*/0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
/*ROW2*/0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
/*ROW3*/0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
/*ROW4*/0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
/*ROW5*/0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
/*ROW6*/0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
/*ROW7*/0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
/*ROW8*/0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
/*ROW9*/0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
/*ROWA*/0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
/*ROWB*/0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
/*ROWC*/0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
/*ROWD*/0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
/*ROWE*/0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
/*NC  */0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, };

static const Drv_Iw7027Param_t Iw7027_DefaultParam =
{ .u16IwOutputFreq = 120, .u8IwCurrent = 0x80, .eIwDelayTableSelect = d2D, .u16IwInputFreq = 120, .u16IwOutputDelay = 1,
		.fIwRunErrorCheck = 1, .fIwErrorType = 0 };

/***2.4 External Variables ***************************************************/

/***2.5 Internal Functions ***************************************************/

/***2.6 External Functions ***************************************************/

void Iw7027_writeMultiByte(uint8 chipsel, uint8 regaddress, uint8 length, uint8 *txdata)
{
	//Selest chip
	Hal_SpiMaster_setCsPin(chipsel);
	DELAY_US(IW_SPI_MASTER_TRANS_START_DELAY);

	//Send Head & address
	Hal_SpiMaster_sendSingleByte(0x01);
	Hal_SpiMaster_sendSingleByte(length);
	Hal_SpiMaster_sendSingleByte(regaddress);

	//Send multi data
	Hal_SpiMaster_sendMultiByte(txdata, length);

	//Unselest all chip
	DELAY_US(IW_SPI_MASTER_TRANS_STOP_DELAY);
	Hal_SpiMaster_setCsPin(0x00);

}

void Iw7027_writeSingleByte(uint8 chipsel, uint8 regaddress, uint8 txdata)
{
	//Selest chip
	Hal_SpiMaster_setCsPin(chipsel);
	DELAY_US(IW_SPI_MASTER_TRANS_START_DELAY);

	//Send Head & address
	Hal_SpiMaster_sendSingleByte(0xC0);
	Hal_SpiMaster_sendSingleByte(regaddress);

	//Send Data
	Hal_SpiMaster_sendSingleByte(txdata);

	//Unselest all chip
	DELAY_US(IW_SPI_MASTER_TRANS_STOP_DELAY);
	Hal_SpiMaster_setCsPin(0x00);
}

uint8 Iw7027_readSingleByte(uint8 chipsel, uint8 regaddress)
{
	uint8 readbyte;

	//Selest chip
	Hal_SpiMaster_setCsPin(chipsel);
	DELAY_US(IW_SPI_MASTER_TRANS_START_DELAY);

	//Send Head & address
	Hal_SpiMaster_sendSingleByte(0x41);
	Hal_SpiMaster_sendSingleByte(regaddress | 0x80);

	//2 dummy clocks to read byte
	Hal_SpiMaster_sendSingleByte(0x00);
	readbyte = Hal_SpiMaster_sendSingleByte(0x00);

	//Unselest all chip
	DELAY_US(IW_SPI_MASTER_TRANS_STOP_DELAY);
	Hal_SpiMaster_setCsPin(0x00);

	return readbyte;
}

uint8 Iw7027_readMultiByte(uint8 chipsel, uint8 regaddress, uint8 length, uint8 *rxdata)
{
	uint8 i;

	//Selest chip
	Hal_SpiMaster_setCsPin(chipsel);
	DELAY_US(IW_SPI_MASTER_TRANS_START_DELAY);

	//Send Head & address
	Hal_SpiMaster_sendSingleByte(0x01);
	Hal_SpiMaster_sendSingleByte(length);
	Hal_SpiMaster_sendSingleByte(regaddress | 0x80);

	//set out dummy clocks to read byte
	Hal_SpiMaster_sendSingleByte(0x00);
	while (length--)
	{
		rxdata[i] = Hal_SpiMaster_sendSingleByte(0x00);
	}

	//Unselest all chip
	DELAY_US(IW_SPI_MASTER_TRANS_STOP_DELAY);
	Hal_SpiMaster_setCsPin(0x00);

	return rxdata[length - 1];
}

uint8 Iw7027_checkReadWithTimeout(uint8 chipsel, uint8 regaddress, uint8 checkvalue, uint8 bitmask)
{
	uint8 retrytime;
	uint8 val;
	uint16 chipmask;
	uint8 status;

	//Sequence check from IW_0 -> IW_N
	for (chipmask = IW_0; chipmask < IW_ALL; chipmask = chipmask << 1)
	{
		//Every selected chip check 10 times.
		//If any of the chip check timeout ,return fail.
		if (chipsel & chipmask)
		{
			retrytime = 10;
			status = 1;
			while (--retrytime && status)
			{
				val = Iw7027_readSingleByte((chipsel & chipmask), regaddress);

				if ((val & bitmask) == checkvalue)
				{
					//Correct , set status = 0 to stop loop
					status = 0;
				}
				else
				{
					//Wrong , delay 100us to retry.
					DELAY_US(100);
				}
			}
			if (retrytime == 0)
			{
				//if time out , return fail
				return FLAG_FAIL;
			}
		}
	}

	//Check loop finish ,return success .
	return FLAG_SUCCESS;

}

uint8 Iw7027_init(void)
{
	uint8 status = 0;
	uint8 i = 0;

	//Step 1: Power ON .
	//YZF 2016/4/30 : Force power off for 500ms to ensure IW7027 is powerd off AC DIP conditon.
	Gpio_out(GPIO_IW_POWER_EN, 0);
	DELAY_MS(500);
	Gpio_out(GPIO_IW_POWER_EN, 1);
	DELAY_MS(200);

	//Step 2: Check chip ID.
	while (FLAG_FAIL == Iw7027_checkChipId(IW_ALL))
	{
		DELAY_MS(200);
	}

	//Step 3: Write initial setting.
	for (i = 0; i < IW_DEVICE_AMOUNT; i++)
	{
		Iw7027_writeMultiByte(IW_0 << i, 0x00, 0x60, (uint8 *) &Iw7027_DefaultRegMap[0x60 * i]);
	}

	//Step 4: Wait STB_IN.
	while (0 == Gpio_in(GPIO_STB_IN))
	{
		DELAY_MS(200);
	}

	//Step 5: Update default parameters to IW7027.
	tDrv_Iw7027Param = Iw7027_DefaultParam;
	Iw7027_updateWorkParams(&tDrv_Iw7027Param);
	//wait 200ms for pwm stable.
	DELAY_MS(200);

	//Step 6 : Initialize Done ,turn on BL
	Iw7027_writeSingleByte(IW_ALL, 0x00, 0x07);

	//Return status
	return status;
}

uint8 Iw7027_updateDuty(uint16 *dutymatrix)
{
	uint8 i;

	static uint8 Iw7027_SortBuff[IW_DEVICE_AMOUNT * 32];

	//Sort duty matrix by LED_sort_map
	for (i = 0; i < IW_LED_CHANNEL; i++)
	{
		//convert 1 16bit data -> 2 8bit data . with resorted in LED hardware order
		Iw7027_SortBuff[2 * Iw7027_LedSortMap[i]] = dutymatrix[i] >> 8;
		Iw7027_SortBuff[2 * Iw7027_LedSortMap[i] + 1] = dutymatrix[i] & 0xFF;
	}

	//Sequence write chip IW0 ~ IW_N
	for (i = 0; i < IW_DEVICE_AMOUNT; i++)
	{
		Iw7027_writeMultiByte( IW_0 << i, 0x40, 32, Iw7027_SortBuff + 32 * i);
	}

	return FLAG_SUCCESS;
}

uint8 Iw7027_updateCurrent(uint8 current)
{
	uint8 status;

	//Write data to IW7027
	//1 . Disable Protect , Set [FAUL_LOCK] (0x62  BIT0)to 1
	Iw7027_writeSingleByte( IW_ALL, 0x62, 0x01);

	//2 . Write current to 0x27
	Iw7027_writeSingleByte( IW_ALL, 0x27, current);

	//3 . Check status. Low 4 bit of 0xB3 = 0x05
	status = Iw7027_checkReadWithTimeout( IW_ALL, 0xB3, 0x05, 0x0F);

	//4 . Enable Protect , Set [FAULT LOCK] (0x62  BIT0)to 0 ,IDAC_REMAP + FAUL_LOCK
	Iw7027_writeSingleByte( IW_ALL, 0x62, 0x00);

	return status;
}

uint8 Iw7027_updateFrequency(uint8 freq)
{
	uint8 pllval;

	//Determine current register value accroding to Iw7027 datasheet
	switch (freq)
	{
	case 50:
		pllval = 48;
		break;
	case 60:
		pllval = 40;
		break;
	case 100:
		pllval = 24;
		break;
	case 120:
		pllval = 20;
		break;
	default:
		return FLAG_FAIL;
	}

	//1 .	Set [PLL_OUTDIV] (0x31 BIT0~BIT4) , Set [PLL_EN] (0x31 BIT7) = 1
	Iw7027_writeSingleByte( IW_ALL, 0x31, pllval + BIT7);

	//2.	Set [PWM_PER_SEL] (0x2F BIT7) =1,Load PWM period from register 0x21[4:0] and 0x22[7:0]
	Iw7027_writeSingleByte( IW_ALL, 0x2F, BIT7);

	//3.	Set [PWM_PER] (0x21 BIT0~BIT4 , 0x22 BIT0~BIT7 ) to 4095 (0x0fff)
	Iw7027_writeSingleByte( IW_ALL, 0x21, 0x0F);
	Iw7027_writeSingleByte( IW_ALL, 0x22, 0xFF);

	//5.	Check [RO_PLL_LOCK]	(0x84 BIT4)	to ensuer PLL work well
	if (Iw7027_checkReadWithTimeout( IW_ALL, 0x84, BIT4, BIT4))
	{
		//return pll value when success
		return FLAG_SUCCESS;
	}
	else
	{
		return FLAG_FAIL;
	}
}

uint8 Iw7027_updateDelayTable(enum Iw7027_Delay_e delay)
{
	return FLAG_SUCCESS;
}

uint8 Iw7027_updateWorkParams(Drv_Iw7027Param_t *param_in)
{
	static Drv_Iw7027Param_t param_now;

	//Update IW7027_PLL & Vsync_Out when changed.
	if (param_now.u16IwOutputFreq != param_in->u16IwOutputFreq)
	{
		param_now.u16IwOutputFreq = param_in->u16IwOutputFreq;
		Iw7027_updateFrequency(param_now.u16IwOutputFreq);
	}

	if ((param_now.u16IwInputFreq != param_in->u16IwInputFreq) || (param_now.u16IwOutputDelay != param_in->u16IwOutputDelay))
	{
		param_now.u16IwInputFreq = param_in->u16IwInputFreq;
		param_now.u16IwOutputDelay = param_in->u16IwOutputDelay;
		Hal_PwmOut_init(param_now.u16IwInputFreq, param_now.u16IwOutputDelay);
	}

	//Update current when changed.
	//YZF 20150526: set current change step
	if (param_now.u8IwCurrent != param_in->u8IwCurrent)
	{
		while (param_now.u8IwCurrent != param_in->u8IwCurrent)
		{
			param_now.u8IwCurrent = min((uint16) param_in->u8IwCurrent,
					(uint16) param_now.u8IwCurrent + IW_CURRENT_CHANGE_STEP);
			Iw7027_updateCurrent(param_now.u8IwCurrent);
		}

	}

	//Update delay table when changed.
	if (param_now.eIwDelayTableSelect != param_in->eIwDelayTableSelect)
	{
		param_now.eIwDelayTableSelect = param_in->eIwDelayTableSelect;
		Iw7027_updateDelayTable(param_now.eIwDelayTableSelect);
	}

	if (param_in->fIwRunErrorCheck)
	{
		Iw7027_checkOpenShortStatus(param_in);
		param_in->fIwRunErrorCheck = 0;
	}

	return FLAG_SUCCESS;

}

uint8 Iw7027_checkOpenShortStatus(Drv_Iw7027Param_t *iwparam)
{
	uint8 i;
	uint8 statusbuf[6];

	//Reset Is error
	iwparam->fIwErrorType = 0;

	//Enable Error Read
	Iw7027_writeSingleByte( IW_ALL, 0x78, 0x80);

	//Read Open/Short/DSShort status from 0x85~0x8A for all device
	for (i = 0; i < IW_DEVICE_AMOUNT; i++)
	{
		Iw7027_readMultiByte(IW_0 << i, 0x85, 6, statusbuf);

		//Set error type
		if (statusbuf[0] || statusbuf[1])
		{
			iwparam->fIwErrorType |= IW_ERR_OPEN;
		}
		if (statusbuf[2] || statusbuf[3])
		{
			iwparam->fIwErrorType |= IW_ERR_SHORT;
		}
		if (statusbuf[4] || statusbuf[5])
		{
			iwparam->fIwErrorType |= IW_ERR_DSSHORT;
		}

		//Set error channel
		iwparam->u8IwOpenShortStatus[i * 2] = statusbuf[0] | statusbuf[2] | statusbuf[4];
		iwparam->u8IwOpenShortStatus[i * 2 + 1] = statusbuf[1] | statusbuf[3] | statusbuf[5];
	}

	//Disable Error¡¡Read
	Iw7027_writeSingleByte( IW_ALL, 0x78, 0x00);

	//Rrturn error status.
	return iwparam->fIwErrorType;
}

flag Iw7027_checkChipId(uint16 iw_all)
{
	uint8 status;
	uint8 i;
	uint8 retval = 0;

	//Check from IW_0 ~ IW_N
	for (i = 0; (IW_0 << i) <= iw_all; i++)
	{
		if ((IW_0 << i) & iw_all)
		{
			status = Iw7027_checkReadWithTimeout(IW_0 << i, 0x68, 0x24, 0xFF);
			retval |= (IW_0 << i) && status;
		}
	}

#if UART_DEBUG_ON
	PrintTime(&tHal_Time);
	PrintString("[IW7027 Chip ID Check Result] = ");
	PrintChar(retval);
	PrintEnter();
#endif

	if (retval == iw_all)
	{
		return FLAG_SUCCESS;
	}
	else
	{
		return FLAG_FAIL;
	}
}

void Iw7027_disableChannel(uint8 ch_id)
{
	;
}
